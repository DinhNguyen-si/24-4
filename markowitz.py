# -*- coding: utf-8 -*-
"""markowitz

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16rc5N9sqnF2XLijgjkiS97PQHvN_NSd4
"""

import numpy as np
import pandas as pd
from scipy.optimize import minimize
from typing import List, Dict, Tuple, Optional

# Sector map
vn30_sector_map = {
    'VNM': 'Consumer Staples', 'VCB': 'Financials', 'VIC': 'Real Estate',
    'VHM': 'Real Estate', 'VRE': 'Real Estate', 'HPG': 'Materials',
    'GAS': 'Energy', 'PLX': 'Energy', 'POW': 'Utilities',
    'MWG': 'Consumer Discretionary', 'PNJ': 'Consumer Discretionary',
    'FPT': 'Information Technology', 'STB': 'Financials', 'TPB': 'Financials',
    'TCB': 'Financials', 'CTG': 'Financials', 'MBB': 'Financials',
    'BID': 'Financials', 'SSI': 'Financials', 'VCI': 'Financials',
    'HDB': 'Financials', 'SHB': 'Financials', 'VIB': 'Financials',
    'MSN': 'Consumer Staples', 'SAB': 'Consumer Staples', 'BVH': 'Financials',
    'KDH': 'Real Estate', 'NVL': 'Real Estate', 'PDR': 'Real Estate',
    'SBT': 'Consumer Staples'
}
sector_df = pd.DataFrame([{'id': k, 'sector': v} for k, v in vn30_sector_map.items()])


def markowitz_optimal_portfolio(
    df: pd.DataFrame,
    sector_df: pd.DataFrame,
    top_n: int = 10,
    max_sector_weight: float = 0.25,
    max_stock_weight: float = 0.10,
    risk_free_rate: float = 0.0,
    verbose: bool = False
) -> Tuple[List[str], Dict[str, float]]:
    """
    Tối ưu danh mục theo mô hình Markowitz có ràng buộc ngành và tỷ trọng cổ phiếu.

    Parameters:
        df (DataFrame): Dữ liệu giá gồm ['id', 'date', 'close']
        sector_df (DataFrame): Dữ liệu ngành gồm ['id', 'sector']
        top_n (int): Số cổ phiếu tối đa trong danh mục
        max_sector_weight (float): Tỷ trọng tối đa mỗi ngành
        max_stock_weight (float): Tỷ trọng tối đa mỗi cổ phiếu
        risk_free_rate (float): Lãi suất phi rủi ro để tính Sharpe ratio
        verbose (bool): In log chi tiết

    Returns:
        selected_ids (List[str]): Danh sách mã cổ phiếu được chọn
        selected_weights (Dict[str, float]): Tỷ trọng tương ứng
    """
    # ===== 1. Tính toán lợi suất =====
    df = df.copy()
    df = df.sort_values(by=['id', 'date'])
    df['return'] = df.groupby('id')['close'].pct_change()
    df.dropna(inplace=True)

    pivot_returns = df.pivot(index='date', columns='id', values='return').dropna()
    tickers = pivot_returns.columns.tolist()

    if len(tickers) < top_n:
        raise ValueError(f"Số cổ phiếu ({len(tickers)}) nhỏ hơn yêu cầu top_n ({top_n})")

    mean_returns = pivot_returns.mean()
    cov_matrix = pivot_returns.cov()

    # ===== 2. Gán ngành và chuẩn bị ràng buộc =====
    sector_map = sector_df.set_index('id')['sector'].to_dict()
    sectors = [sector_map.get(t, 'Unknown') for t in tickers]
    sector_set = list(set(sectors))

    if verbose:
        print("Tickers:", tickers)
        print("Sectors:", sector_set)

    # ===== 3. Hàm mục tiêu - Max Sharpe Ratio =====
    def neg_sharpe_ratio(weights):
        port_return = np.dot(weights, mean_returns)
        port_vol = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))
        if port_vol < 1e-8:  # To avoid division by zero
            return np.inf
        sharpe = (port_return - risk_free_rate) / port_vol
        return -sharpe

    # ===== 4. Ràng buộc =====
    constraints = [{'type': 'eq', 'fun': lambda w: np.sum(w) - 1}]  # Weights must sum to 1

    for sector in sector_set:
        idx = [i for i, s in enumerate(sectors) if s == sector]
        constraints.append({
            'type': 'ineq',
            'fun': lambda w, idx=idx: max_sector_weight - np.sum(w[idx])
        })

    # ===== 5. Giới hạn và khởi tạo =====
    bounds = [(0, max_stock_weight)] * len(tickers)
    init_guess = np.array([1. / len(tickers)] * len(tickers))  # Equal initial allocation

    # ===== 6. Tối ưu hóa =====
    result = minimize(
        neg_sharpe_ratio,
        init_guess,
        bounds=bounds,
        constraints=constraints,
        method='trust-constr'  # More robust for constraints
    )

    if not result.success:
        raise RuntimeError(f"Tối ưu thất bại: {result.message}")

    # ===== 7. Chọn top_n cổ phiếu =====
    weights = result.x
    weight_dict = dict(zip(tickers, weights))
    sorted_weights = sorted(weight_dict.items(), key=lambda x: x[1], reverse=True)

    top_assets = sorted_weights[:top_n]
    selected_ids = [t for t, _ in top_assets]

    # Chuẩn hóa lại trọng số cho top_n
    total_weight = sum([weight_dict[t] for t in selected_ids])
    selected_weights = {t: weight_dict[t] / total_weight for t in selected_ids}

    if verbose:
        print("Selected:", selected_weights)

    return selected_ids, selected_weights