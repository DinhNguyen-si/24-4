# -*- coding: utf-8 -*-
"""metrics

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Wi7hFS6jpWY4v_z1yWUR9e2i-NfQopCU
"""

import numpy as np

def sharpe_ratio(returns, risk_free_rate=0.035, periods_per_year=252):
    returns = np.array(returns)
    if len(returns) == 0:
        return 0.0
    excess_returns = returns - (risk_free_rate / periods_per_year)
    std_dev = np.std(excess_returns)
    if std_dev < 1e-8 or np.isnan(std_dev):
        return 0.0
    return np.mean(excess_returns) / std_dev

def sortino_ratio(returns, risk_free_rate=0.035, periods_per_year=252):
    returns = np.array(returns)
    excess_returns = returns - (risk_free_rate / periods_per_year)
    downside_returns = excess_returns[excess_returns < 0]
    downside_std = np.std(downside_returns)
    if downside_std < 1e-8 or np.isnan(downside_std):
        return 0.0
    return np.mean(excess_returns) / downside_std

def max_drawdown(cumulative_returns):
    cumulative_returns = np.array(cumulative_returns)
    if len(cumulative_returns) == 0:
        return 0.0
    peak = np.maximum.accumulate(cumulative_returns)
    drawdowns = (cumulative_returns - peak) / (peak + 1e-8)
    return drawdowns.min()

def max_drawdown_duration(cumulative_returns):
    peak = np.maximum.accumulate(cumulative_returns)
    drawdown_duration = 0
    max_duration = 0
    for i in range(len(cumulative_returns)):
        if cumulative_returns[i] < peak[i]:
            drawdown_duration += 1
            max_duration = max(max_duration, drawdown_duration)
        else:
            drawdown_duration = 0
    return max_duration

def volatility(returns, periods_per_year=252):
    std = np.std(returns)
    return std * np.sqrt(periods_per_year) if not np.isnan(std) else 0.0

def cagr(returns, periods_per_year=252):
    returns = np.array(returns)
    if len(returns) == 0:
        return 0.0
    cumulative_return = np.prod(1 + returns)
    n_years = len(returns) / periods_per_year
    if cumulative_return <= 0 or n_years <= 0:
        return 0.0
    return cumulative_return ** (1 / n_years) - 1

def buy_and_hold_return(prices):
    prices = np.array(prices)
    if len(prices) < 2 or prices[0] == 0:
        return 0.0
    return (prices[-1] / prices[0]) - 1

def evaluate_performance(returns, prices=None, risk_free_rate=0.035, periods_per_year=252):
    returns = np.array(returns)
    returns = returns[~np.isnan(returns)]
    returns = returns[~np.isinf(returns)]

    if len(returns) == 0:
        return {
            "Sharpe Ratio": 0.0,
            "Sortino Ratio": 0.0,
            "Volatility": 0.0,
            "CAGR": 0.0,
            "Max Drawdown": 0.0,
            "Max Drawdown Duration": 0,
            "Calmar Ratio": 0.0,
            "Buy & Hold Return": 0.0
        }

    cumulative_returns = np.cumprod(1 + returns)
    mdd = max_drawdown(cumulative_returns)
    cagr_val = cagr(returns, periods_per_year)
    calmar = abs(cagr_val / mdd) if mdd < 0 else 0.0

    return {
        "Sharpe Ratio": sharpe_ratio(returns, risk_free_rate, periods_per_year),
        "Sortino Ratio": sortino_ratio(returns, risk_free_rate, periods_per_year),
        "Volatility": volatility(returns, periods_per_year),
        "CAGR": cagr_val,
        "Max Drawdown": mdd,
        "Max Drawdown Duration": max_drawdown_duration(cumulative_returns),
        "Calmar Ratio": calmar,
        "Buy & Hold Return": buy_and_hold_return(prices) if prices is not None else 0.0
    }