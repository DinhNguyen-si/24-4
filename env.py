# -*- coding: utf-8 -*-
"""env

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nzdYnt5wJoXoXC4FaIAt7wJa_tWxtF1V
"""

import numpy as np
import pandas as pd
import gymnasium as gym
from gymnasium import spaces
from typing import List, Dict, Tuple, Optional
from .metrics import evaluate_performance


class VN30TradingEnv(gym.Env):
    metadata = {"render_modes": ["human"], "render_fps": 4}

    def __init__(
        self,
        df: pd.DataFrame,
        tickers: List[str],
        strategy_dict: Dict[str, object],  # Dict chứa các chiến lược
        window_size: int = 10,
        initial_cash: float = 1_000_000.0,
        trading_fee: float = 0.001
    ):
        super().__init__()

        # Lưu dữ liệu
        self.df = df.copy().reset_index(drop=True)
        self.tickers = tickers
        self.strategy_dict = strategy_dict
        self.strategy_names = list(self.strategy_dict.keys())
        self.window_size = window_size
        self.initial_cash = initial_cash
        self.trading_fee = trading_fee

        # Kiểm tra dữ liệu đầu vào
        if "date" not in self.df.columns or "id" not in self.df.columns:
            raise ValueError("DataFrame must contain 'date' and 'id' columns.")
        self.df["date"] = pd.to_datetime(self.df["date"])

        # Tạo asset_data theo tickers
        self.asset_data = {
            t: self.df[self.df["id"] == t].reset_index(drop=True)
            for t in self.tickers
            if not self.df[self.df["id"] == t].empty
        }

        if not self.asset_data:
            raise ValueError("No data available for specified tickers.")

        self.num_assets = len(self.asset_data)
        self.feature_cols = [
            col for col in self.df.columns if col not in ["date", "id"]
        ]
        self.num_features = len(self.feature_cols)
        self.max_steps = min(len(d) for d in self.asset_data.values())

        # Khởi tạo các không gian
        self.observation_space = spaces.Box(
            low=-np.inf,
            high=np.inf,
            shape=(self.window_size * self.num_assets * self.num_features,),
            dtype=np.float32,
        )
        self.action_space = spaces.Box(
            low=-1.0,
            high=1.0,
            shape=(self.num_assets,),
            dtype=np.float32,
        )

        # Khởi tạo trạng thái ban đầu
        self._init_state()

    def _init_state(self):
        """Khởi tạo trạng thái ban đầu của môi trường"""
        self.current_step = self.window_size
        self.cash_balance = self.initial_cash
        self.asset_balance = np.zeros(self.num_assets, dtype=np.float32)
        self.weights = np.zeros(self.num_assets, dtype=np.float32)
        self.portfolio_value = self.initial_cash
        self.history_returns = []
        self.history_values = []
        self.strategy_rewards = {name: [] for name in self.strategy_names}

    def reset(self, seed=None, options=None):
        """Đặt lại trạng thái ban đầu và trả về quan sát"""
        super().reset(seed=seed)
        self._init_state()
        obs = self._get_observation()
        info = {"portfolio_value": self.portfolio_value}
        return obs, info

    def step(self, action: np.ndarray):
        """Chạy một bước trong môi trường, tính toán phần thưởng và cập nhật trạng thái"""
        # Ràng buộc hành động trong phạm vi cho phép
        action = np.clip(action, self.action_space.low, self.action_space.high)
        norm_action = action / (np.sum(np.abs(action)) + 1e-8)

        if self.current_step >= self.max_steps:
            return self._end_step()

        # Tính toán tỷ suất sinh lời
        prev_prices = self._get_prices(self.current_step - 1)
        curr_prices = self._get_prices(self.current_step)
        returns = (curr_prices - prev_prices) / (prev_prices + 1e-8)

        strategy_perf = {}
        for name, strategy in self.strategy_dict.items():
            # Nếu chiến lược là một danh sách, tính toán tín hiệu trung bình
            if isinstance(strategy, list):
                signals = []
                for s in strategy:
                    sig = s.generate_signal(self.df.iloc[:self.current_step + 1])
                    if isinstance(sig, np.ndarray):
                        sig = sig[-1]
                    signals.append(float(sig))
                signal = np.mean(signals)
            else:
                signal = strategy.generate_signal(self.df.iloc[:self.current_step + 1])
                if isinstance(signal, np.ndarray):
                    signal = float(signal[-1])

            # Tính phần thưởng cho chiến lược
            reward = float(np.dot(norm_action, returns) * signal)
            strategy_perf[name] = reward
            self.strategy_rewards[name].append(reward)

        best_strategy = max(strategy_perf, key=strategy_perf.get)
        reward = strategy_perf[best_strategy]

        # Cập nhật danh mục đầu tư
        self._update_portfolio(norm_action, curr_prices)
        self.history_returns.append(reward)
        self.history_values.append(self.portfolio_value)
        self.weights = norm_action.copy()
        self.current_step += 1

        terminated = self.current_step >= self.max_steps
        truncated = False
        obs = self._get_observation()
        info = {
            "reward": reward,
            "portfolio_value": self.portfolio_value,
            "best_strategy": best_strategy
        }

        return obs, reward, terminated, truncated, info

    def _get_observation(self) -> np.ndarray:
        """Lấy quan sát từ môi trường hiện tại"""
        window = np.zeros((self.window_size, self.num_assets, self.num_features), dtype=np.float32)
        for i, ticker in enumerate(self.tickers):
            data = self.asset_data[ticker]
            window[:, i, :] = data.iloc[self.current_step - self.window_size:self.current_step][self.feature_cols].values
        return window.flatten()

    def _get_prices(self, step: int) -> np.ndarray:
        """Lấy giá cổ phiếu tại bước thời gian nhất định"""
        prices = np.zeros(self.num_assets, dtype=np.float32)
        for i, ticker in enumerate(self.tickers):
            prices[i] = float(self.asset_data[ticker].iloc[step]["close"])
        return prices

    def _update_portfolio(self, weights: np.ndarray, prices: np.ndarray):
        """Cập nhật danh mục đầu tư theo trọng số và giá cổ phiếu"""
        total_value = self.get_portfolio_value()
        target_val = weights * total_value
        current_val = self.asset_balance * prices
        delta_val = target_val - current_val
        delta_shares = delta_val / (prices + 1e-8)

        # Phí giao dịch
        cost = np.sum(np.abs(delta_shares * prices) * self.trading_fee)

        self.asset_balance += delta_shares
        self.cash_balance = total_value - np.sum(self.asset_balance * prices) - cost
        self.portfolio_value = self.get_portfolio_value()

    def get_portfolio_value(self) -> float:
        """Tính giá trị danh mục đầu tư"""
        if self.current_step < self.window_size:
            return self.initial_cash
        prices = self._get_prices(self.current_step - 1)
        return float(self.cash_balance + np.sum(self.asset_balance * prices))

    def render(self):
        """Hiển thị thông tin môi trường"""
        print(f"Step {self.current_step}/{self.max_steps} - Value: {self.portfolio_value:,.2f}")
        if self.history_returns:
            print(f"Last reward: {self.history_returns[-1]:.5f}")

    def _end_step(self):
        """Kết thúc một bước và trả về kết quả cuối cùng"""
        obs = np.zeros_like(self.observation_space.sample())
        perf = evaluate_performance(self.history_returns, self.history_values)
        info = {
            "terminated": True,
            "final_portfolio_value": self.portfolio_value,
            "performance": perf
        }
        return obs, 0.0, True, False, info

