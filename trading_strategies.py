# -*- coding: utf-8 -*-
"""trading_strategies

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kPJzxAUNgs8iJW1-OSpoU2cIBFP5CfXt
"""

import numpy as np
import pandas as pd
from typing import List, Dict, Tuple, Optional
# Base Strategy
class TradingStrategy:
    def generate_signal(self, df_slice: pd.DataFrame) -> np.ndarray:
        raise NotImplementedError("Subclasses must implement generate_signal")
# 1. Grid Strategy
class GridStrategy(TradingStrategy):
    def __init__(self, grid_size=1.0, base_price=100.0):
        self.grid_size = grid_size
        self.base_price = base_price

    def generate_signal(self, df_slice: pd.DataFrame) -> np.ndarray:
        return np.where(
            df_slice['close'] > self.base_price + self.grid_size, -1,
            np.where(df_slice['close'] < self.base_price - self.grid_size, 1, 0)
        )
# 2. Momentum Strategy
class MomentumStrategy(TradingStrategy):
    def __init__(self, short_window=5, long_window=20):
        self.short_window = short_window
        self.long_window = long_window

    def generate_signal(self, df_slice: pd.DataFrame) -> np.ndarray:
        sma_s = df_slice['close'].rolling(self.short_window).mean()
        sma_l = df_slice['close'].rolling(self.long_window).mean()
        return np.where(sma_s > sma_l, 1, -1)
# 3. Median Reversion Strategy
class MedianReversionStrategy(TradingStrategy):
    def __init__(self, window=20):
        self.window = window

    def generate_signal(self, df_slice: pd.DataFrame) -> np.ndarray:
        median = df_slice['close'].rolling(self.window).median()
        return np.where(df_slice['close'] > median, -1, 1)
# 4. Market Arbitrage Strategy
class MarketArbitrageStrategy(TradingStrategy):
    def __init__(self, df1: pd.DataFrame, df2: pd.DataFrame):
        self.df1 = df1.reset_index(drop=True)
        self.df2 = df2.reset_index(drop=True)

    def generate_signal(self, df_slice: pd.DataFrame) -> np.ndarray:
        spread = self.df1['close'] - self.df2['close']
        mean_spread = spread.mean()
        return np.where(spread > mean_spread, -1, np.where(spread < mean_spread, 1, 0))
# 5. Market Neutral Strategy
class MarketNeutralStrategy(TradingStrategy):
    def generate_signal(self, df_slice: pd.DataFrame) -> np.ndarray:
        median = df_slice['close'].median()
        return np.where(df_slice['close'] > median, -1, 1)
# 6. Pair Trading Strategy
class PairTradingStrategy(TradingStrategy):
    def __init__(self, df1: pd.DataFrame, df2: pd.DataFrame):
        self.df1 = df1.reset_index(drop=True)
        self.df2 = df2.reset_index(drop=True)

    def generate_signal(self, df_slice: pd.DataFrame) -> np.ndarray:
        spread = self.df1['close'] - self.df2['close']
        mean, std = spread.mean(), spread.std()
        return np.where(spread > mean + std, -1, np.where(spread < mean - std, 1, 0))

# 7. Event-Driven Strategy
class EventDrivenStrategy(TradingStrategy):
    def __init__(self, trigger_price: float):
        self.trigger = trigger_price

    def generate_signal(self, df_slice: pd.DataFrame) -> np.ndarray:
        return np.where(df_slice['close'] >= self.trigger, 1,
                        np.where(df_slice['close'] <= self.trigger, -1, 0))
# 8. Beta (Factor) Strategy
class BetaStrategy(TradingStrategy):
    def __init__(self, threshold=0.01):
        self.threshold = threshold

    def generate_signal(self, df_slice: pd.DataFrame) -> np.ndarray:
        returns = df_slice['close'].pct_change().fillna(0)
        return np.where(returns > self.threshold, 1, -1)
# 9. Statistical Arbitrage Strategy
class StatisticalArbitrageStrategy(TradingStrategy):
    def __init__(self, df1: pd.DataFrame, df2: pd.DataFrame):
        self.df1 = df1.reset_index(drop=True)
        self.df2 = df2.reset_index(drop=True)

    def generate_signal(self, df_slice: pd.DataFrame) -> np.ndarray:
        spread = self.df1['close'] - self.df2['close']
        mean = spread.mean()
        corr = self.df1['close'].corr(self.df2['close'])
        return np.where(corr > 0.5,
                        np.where(spread > mean, -1, np.where(spread < mean, 1, 0)),
                        np.zeros(len(spread), dtype=int))
# 10. Scalping Strategy
class ScalpingStrategy(TradingStrategy):
    def __init__(self, window=1):
        self.window = window

    def generate_signal(self, df_slice: pd.DataFrame) -> np.ndarray:
        sma = df_slice['close'].rolling(self.window).mean()
        return np.where(df_slice['close'] > sma, 1, -1)
# 11. ETF Rebalance Strategy
class ETFRebalanceStrategy(TradingStrategy):
    def __init__(self, etf_weights: dict):
        self.weights = etf_weights

    def generate_signal(self, df_slice: pd.DataFrame) -> np.ndarray:
        stock_ids = df_slice["id"].values
        return np.array([1 if self.weights.get(stock_id, 0) > 0 else 0 for stock_id in stock_ids], dtype=int)
# 12. Market Making Strategy
class MarketMakingStrategy(TradingStrategy):
    def __init__(self, spread=0.5):
        self.spread = spread

    def generate_signal(self, df_slice: pd.DataFrame) -> np.ndarray:
        signals = np.zeros(len(df_slice), dtype=int)
        for i in range(1, len(df_slice)):
            prev_close, curr_close = df_slice['close'].iloc[i-1], df_slice['close'].iloc[i]
            if curr_close < prev_close - self.spread:
                signals[i] = 1
            elif curr_close > prev_close + self.spread:
                signals[i] = -1
        return signals