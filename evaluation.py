# -*- coding: utf-8 -*-
"""evaluation

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FuWmQCFQQpRMsFcCHjpPNsljPYV31sHn
"""

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
from typing import List, Dict
from stable_baselines3 import PPO
from stable_baselines3.common.vec_env import DummyVecEnv
from my_project.utils import sharpe_ratio, sortino_ratio, volatility, cagr, max_drawdown, max_drawdown_duration

def evaluate_model(
    model_path: str,
    df: pd.DataFrame,
    tickers: List[str],
    strategy_dict: Dict[str, object],
    window_size: int = 10,
    initial_cash: float = 10_000.0,
    plot: bool = True
) -> Dict[str, float]:
    """
    Load a trained PPO-LSTM model and evaluate its performance on VN30TradingEnv.
    Returns key performance metrics and optional plots.
    """
    # Prepare data
    df_eval = add_technical_indicators(df.copy())  # Giả sử bạn đã định nghĩa add_technical_indicators
    df_eval['date'] = pd.to_datetime(df_eval['date'])

    # Buy & Hold on VN30 index if available
    bh_return = None
    if 'VN30' in df_eval['id'].unique():
        idx = df_eval[df_eval['id'] == 'VN30'].sort_values('date')
        bh_return = float(idx['close'].iloc[-1] / idx['close'].iloc[0] - 1)

    # Create evaluation environment
    env = VN30TradingEnv(df=df_eval, tickers=tickers, strategy_dict=strategy_dict,
                         window_size=window_size, initial_cash=initial_cash)

    # Load the PPO-LSTM model
    model = PPO.load(model_path)

    # Evaluate the model
    obs, _ = env.reset()
    done = False
    portfolio = [initial_cash]
    returns_list, dates = [], []

    while not done:
        action, _ = model.predict(obs, deterministic=True)
        obs, reward, terminated, truncated, info = env.step(action)
        done = terminated or truncated
        portfolio.append(env.get_portfolio_value())
        returns_list.append(reward)
        dates.append(env.current_date)

    port_arr = np.array(portfolio)
    returns_arr = np.diff(port_arr) / port_arr[:-1]
    cum_returns = np.cumprod(1 + returns_arr)

    # Compute metrics
    metrics = {
        'Total Return': float(port_arr[-1] / port_arr[0] - 1),
        'Sharpe Ratio': sharpe_ratio(returns_arr),
        'Sortino Ratio': sortino_ratio(returns_arr),
        'Volatility': volatility(returns_arr),
        'CAGR': cagr(returns_arr),
        'Max Drawdown': max_drawdown(cum_returns),
        'Max Drawdown Duration': max_drawdown_duration(cum_returns),
        'Calmar Ratio': abs(cagr(returns_arr) / max_drawdown(cum_returns))
    }

    if bh_return is not None:
        metrics['Buy & Hold'] = bh_return

    # Plotting
    if plot:
        # Plot Portfolio Value
        dates = pd.to_datetime(dates)
        plt.figure(figsize=(12, 5))
        plt.plot(dates, portfolio[1:], label='Agent Portfolio')
        if bh_return is not None:
            plt.hlines(port_arr[0] * (1 + bh_return), dates[0], dates[-1],
                       colors='red', linestyles='--', label='Buy & Hold Portfolio')
        plt.title('Portfolio Value')
        plt.legend()
        plt.show()

        # Plot Returns Distribution
        plt.figure(figsize=(8, 4))
        sns.histplot(returns_arr, bins=50, kde=True)
        plt.title('Returns Distribution')
        plt.show()

        # Plot Drawdown Curve
        drawdown = cum_returns - np.maximum.accumulate(cum_returns)
        plt.figure(figsize=(12, 5))
        plt.plot(dates, drawdown)
        plt.title('Drawdown Curve')
        plt.show()

        # Performance Metrics Bar
        plt.figure(figsize=(10,4))
        sns.barplot(x=list(metrics.keys()), y=list(metrics.values()))
        plt.xticks(rotation=30)
        plt.title('Performance Metrics')
        plt.show()

    # Print summary
    for k, v in metrics.items():
        print(f"{k}: {v:.4f}" if isinstance(v, float) else f"{k}: {v}")

    return metrics